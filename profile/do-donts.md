# Do/Don’t (y26)

## **Нейминг**

1. [Следуйте правилам нейминга](https://github.com/itmo-is-dev/.github/blob/master/codestyle.md#naming), используйте
   семантику
2. Не использовать сокращения
3. Использовать общепринятые английские термины для нейминга классов/свойств/методов
    1. Не используйте транслитерацию
    2. Не используйте машинный перевод для исконно русских терминов
    3. Не используйте системные/зарезервированные термины в ваших классах
    4. Если термин является сокращением сам по себе, то используйте CamelCase (Например: вместо HTTP используйте Http)

       Пример плохого нейминга:

        ```csharp
        // Метод добавления студента в подпоток 
        class Thread { 
        	void Join(Student student) { … } 
        }
        ```

4. Познакомиться с кодстайлом, префиксами для интерфейсов

## **Do:**

1. [Следуйте кодстайлу](https://github.com/itmo-is-dev/.github/blob/master/codestyle.md#general)
2. Следуйте
   правилам [семантического нейминга комитов](https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716)
3. Использовать конструкторы для создания полностью инициализированного объекта
4. Минимизировать область доступа к данным, закрывать возможность изменять тип из-вне. Стремиться к минимизации
   статических полей. Если поле класса используется только внутри одного метода - инлайнить, если используется для
   передачи данных между методами - перепроектировать решение.
5. Проверяйте может ли метод выполниться с переданными аргументами, если эти аргументы - это пользовательский ввод.
6. При реализации методов создания или поиска, стоит возвращать сущности, а не какие-то их части - названия или
   идентификаторы. Если написано, что нужно найти магазин, то ожидается, что вернется не строка, а магазин.
7. Минимизировать использование статических методов, полей и классов. Если в коде была использована статика, то нужно
   обозначить комментарием почему это решение лучше в таком виде, нежели без статики.
8. Стараться минимизировать вложенность за счет инвертирования условий.
9. Делать всю возможную валидацию аргументов в конструкторе (например, на null)
10. Стараться делать типы иммутабельными. Особенно в кейсах, где мутабельность объекта нужно для инициализации вне
    конструктора:

    ```csharp
    // Плохо:
    var group = new Group(); 
    group.Name = "Tasks";
    
    // Хорошо:
    var group = new Group("Tasks"); 
    ```

11. Поддерживать инвариант типа. Никакое изменение не должно делать экземпляр класса не валидным.
12. Разделять бизнес логику и логику работы с UI. Разделять логику, парсинг аргументов и валидацию
13. Если есть зависимость от внешних сущностей, то их нужно прокидывать аргументами.
14. Бросать понятные ошибки бизнес логики (т.е. не из namespace'a System). Обрабатывать возможные NRE, OutOfRange etc и
    вместо них бросать понятные. Сообщения ошибок стоит писать на английском. Если хочется поддержать русский, то нужно
    смотреть в сторону локализации. (не распространяется на группы 05-08)
15. Старайтесь вместо множества вложенных операторов выделить все граничные условия и обработать их в самом начале
    метода для достижения большей читаемости кода.
    см.[https://refactoring.guru/ru/replace-nested-conditional-with-guard-clauses](https://refactoring.guru/ru/replace-nested-conditional-with-guard-clauses)
16. Используйте свойства/автосвойства вместо геттер/сеттер методов.
17. Использовать LINQ для работы с коллекциями (вместо написания своих вариантов итерации).
18. Используйте
    подход [Arrange-Act-Assert](https://docs.microsoft.com/ru-ru/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests)
    при написании ваших тест-кейсов.
19. Использовать в тестах специализированные проверки вместо общих, по типу
    `Assert.Contains(…)` вместо `Assert.True(collection.Contains(…))`.
20. Стараться работать с абстракциями, а не с конкретными видами коллекций

```csharp
// Плохо:
List<int> FindOddNumbers(int[] numbers) {
  return numbers.Where(x => x % 2 == 0).ToList();
}

// Хорошо:
IEnumerable<T> FindOddNumbers(IReadOnlyCollection<T> numbers) where T : INumber {
  return numbers.Where(x => x % 2 == 0);
}
```

21. Использовать ограничения для явного указания поддерживаемых generic типов (см. пример выше)
22. Соблюдайте принципы [DRY, KISS, YAGNI](https://habr.com/ru/articles/144611/)

- **DRY - Don’t repeat yourself**. Вместо копирования одного куска кода, рекомендуется вынести его в метод для
  дальшейшего переиспользования.
- **KISS - Keep it stupid simple**. Старайтесь делать методы максимально атомарными и не переусложнять логику. Для
  большой сложной операции рекомендуется декомпозировать сценарий на несколько простых.
- **YAGNI - You ain’t gonna need this**. Не добавляйте преждевременные абстракции для того чтобы поддержать какой-то
  сценарий из будущего, для которого ещё неизвестны бизнес требования. Проектируйте непостредственно ту предметную
  область, которая описана в текущей задаче.

## **Don't:**

1. Не вносить изменения в различные файлы конфигурации без апрува преподавателей.
2. Не используйте в коде магические числа. Имеет смысл выносить как константное поле, чтобы по его названию можно было
   понять, что это.
3. Не работать с потоками ввода-вывода в бизнес-логике
4. Ловить и игнорировать исключение, которое не может быть обработано
5. Не используйте default или специализированные (-1, int.MaxValue и т.д.) значения как определение того, что значение
   не найдено. Если метод может не найти результат, то метод нужно называть Find и он должен вернуть null в случае
   ссылочных типов. Для примитивов стоит использовать Nullable. Для коллекций стоит возвращать пустой список или массив,
   если ничего не нашлось, а не null.
6. Избегайте кастов там, где можно их не использовать. Программа должна стремиться к повышению типизации и увеличении
   количества мест, где происходят проверки во время компиляции.
7. Минимизировать количество [down casting](https://qna.habr.com/q/448799). Стараться не использовать более общие типы в
   сигнатурах, если они не поддерживаются.
8. Не использовать Tuple, ValueTuple и KeyValuePair’ы (в т.ч. из словарей) в сигнатурах своих типов или методов.
   Используйте свой Discriminate Union / Value Object / Data Transfer Object для передачи множества значений в качестве
   результата.
9. Не оставлять код, который не нужен\не используется
10. Не нужно комментировать очевидные места

    ```csharp
    static class Program {
      // Точка входа в программу
      static void Main(string[] args) {
        // Вывод привет мир в консоль
        Console.WriteLine("Hello, world!");
      }
    }
    ```

11. Не использовать наследование для переиспользования логики. Если объект наследуется, то справедливым должно быть
    высказывание, что производный объект является базовым (
    см. [LSP](https://www.csharptutorial.net/csharp-design-patterns/csharp-liskov-substitution-principle/)).
12. Не используйте циклы для перебора коллекций ради того чтобы в теле цикла вернуть/найти объект или собрать лист
    значений. Воспользуйтесь LINQ, а именно: `.SelectMany()`, `.Where()`, `.FirstOrDefault()`
13. Не использовать Reflection.
14. Не использовать boolean флаги для того чтобы управлять условиями выхода из цикла.
15. Не использовать SQL-like синтаксис для написания LINQ.
16. Не использовать конструкции вида `.ToList().ForEach(...)` / `.ToList().Select(...)` для итерации по колекциям. (
    Итерация после вызова терминальной операции)
17. Не использовать Regular Expressions
18. Не использовать null forgiving operator
19. Подавлять ошибки статического анализатора (например через `#pragma disable`)
20. Использование публичных полей в классах
21. Не используйте коллекции из namespace’а **System.Collections.ObjectModel**